// ============================================================================
//
// Copyright (c) 2005-2010, Talend Inc.
//
// This source code has been automatically generated by_Talend ESB Standard Edition
// / JobDesigner (CodeGenerator version 4.2.1.r67267)
// You can find more information about Talend products at www.talend.com.
// You may distribute this code under the terms of the GNU LGPL license
// http://www.gnu.org/licenses/lgpl.html).
//
// ============================================================================
package talend_esb_tutorial.simpleprovider_0_1;

import routines.Mathematical;
import routines.DataOperation;
import routines.Relational;
import routines.TalendDate;
import routines.TalendDataGenerator;
import routines.Numeric;
import routines.TalendString;
import routines.StringHandling;
import routines.system.*;
import routines.system.api.*;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.math.BigDecimal;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import java.util.Comparator;

/**
 * Job: SimpleProvider Purpose: <br>
 * Description: <br>
 * 
 * @author user@company.com
 * @version 4.2.1.r67267
 * @status
 */
public class SimpleProvider implements TalendESBJob {

	public final Object obj = new Object();

	// for transmiting parameters purpose
	private Object valueObject = null;

	public Object getValueObject() {
		return this.valueObject;
	}

	public void setValueObject(Object valueObject) {
		this.valueObject = valueObject;
	}

	private final static String defaultCharset = java.nio.charset.Charset
			.defaultCharset().name();

	private final static String utf8Charset = "UTF-8";

	// create and load default properties
	private java.util.Properties defaultProps = new java.util.Properties();

	// create application properties with default
	public class ContextProperties extends java.util.Properties {

		public ContextProperties(java.util.Properties properties) {
			super(properties);
		}

		public ContextProperties() {
			super();
		}

		public void synchronizeContext() {

		}

	}

	private ContextProperties context = new ContextProperties();

	public ContextProperties getContext() {
		return this.context;
	}

	private final String jobVersion = "0.1";
	private final String jobName = "SimpleProvider";
	private final String projectName = "TALEND_ESB_TUTORIAL";
	public Integer errorCode = null;
	private String currentComponent = "";
	private final java.util.Map<String, Long> start_Hash = new java.util.HashMap<String, Long>();
	private final java.util.Map<String, Long> end_Hash = new java.util.HashMap<String, Long>();
	private final java.util.Map<String, Boolean> ok_Hash = new java.util.HashMap<String, Boolean>();
	private final java.util.Map<String, Object> globalMap = new java.util.HashMap<String, Object>();
	public final java.util.List<String[]> globalBuffer = new java.util.ArrayList<String[]>();

	public boolean isExportedAsOSGI = false;

	private final java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
	private final java.io.PrintStream errorMessagePS = new java.io.PrintStream(
			new java.io.BufferedOutputStream(baos));

	public String getExceptionStackTrace() {
		if ("failure".equals(this.getStatus())) {
			errorMessagePS.flush();
			return baos.toString();
		}
		return null;
	}

	private Exception exception = null;

	public Exception getException() {
		if ("failure".equals(this.getStatus())) {
			return this.exception;
		}
		return null;
	}

	private class TalendException extends Exception {
		private java.util.Map<String, Object> globalMap = null;
		private Exception e = null;
		private String currentComponent = null;

		private TalendException(Exception e, String errorComponent,
				final java.util.Map<String, Object> globalMap) {
			this.currentComponent = errorComponent;
			this.globalMap = globalMap;
			this.e = e;
		}

		@Override
		public void printStackTrace() {
			if (!(e instanceof TalendException || e instanceof TDieException)) {
				globalMap.put(currentComponent + "_ERROR_MESSAGE", e
						.getMessage());
				System.err
						.println("Exception in component " + currentComponent);
			}
			if (!(e instanceof TDieException)) {
				if (e instanceof TalendException) {
					e.printStackTrace();
				} else {
					e.printStackTrace();
					e.printStackTrace(errorMessagePS);
					SimpleProvider.this.exception = e;
				}
			}
			if (!(e instanceof TalendException)) {
				try {
					for (java.lang.reflect.Method m : this.getClass()
							.getEnclosingClass().getMethods()) {
						if (m.getName().compareTo(currentComponent + "_error") == 0) {
							m.invoke(SimpleProvider.this, new Object[] { e,
									currentComponent, globalMap });
							break;
						}
					}

					if (!(e instanceof TDieException)) {
					}
				} catch (java.lang.SecurityException e) {
					this.e.printStackTrace();
				} catch (java.lang.IllegalArgumentException e) {
					this.e.printStackTrace();
				} catch (java.lang.IllegalAccessException e) {
					this.e.printStackTrace();
				} catch (java.lang.reflect.InvocationTargetException e) {
					this.e.printStackTrace();
				}
			}
		}
	}

	public void tESBProviderRequest_1_error(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tESBProviderRequest_1", System.currentTimeMillis());

		tESBProviderRequest_1_onSubJobError(exception, errorComponent,
				globalMap);

	}

	public void tLogRow_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tLogRow_1", System.currentTimeMillis());

		tESBProviderRequest_1_onSubJobError(exception, errorComponent,
				globalMap);

	}

	public void tXMLMap_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tXMLMap_1", System.currentTimeMillis());

		tESBProviderRequest_1_onSubJobError(exception, errorComponent,
				globalMap);

	}

	public void tLogRow_3_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tLogRow_3", System.currentTimeMillis());

		tESBProviderRequest_1_onSubJobError(exception, errorComponent,
				globalMap);

	}

	public void tESBProviderResponse_1_error(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tESBProviderResponse_1", System.currentTimeMillis());

		tESBProviderRequest_1_onSubJobError(exception, errorComponent,
				globalMap);

	}

	public void tFileInputDelimited_1_error(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tFileInputDelimited_1", System.currentTimeMillis());

		tFileInputDelimited_1_onSubJobError(exception, errorComponent,
				globalMap);

	}

	public void tLogRow_4_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tLogRow_4", System.currentTimeMillis());

		tFileInputDelimited_1_onSubJobError(exception, errorComponent,
				globalMap);

	}

	public void tAdvancedHash_row5_error(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tAdvancedHash_row5", System.currentTimeMillis());

		tFileInputDelimited_1_onSubJobError(exception, errorComponent,
				globalMap);

	}

	public void tESBProviderRequest_1_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	public void tFileInputDelimited_1_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception), "");

	}

	interface ESBProviderCallbackTalendJobInner extends ESBProviderCallback {
		void sendFault(Throwable e);

		void sendBusinessFault(String faultString,
				org.dom4j.Document faultDetail);
	}

	private ESBEndpointRegistry registry = null;
	private ESBProviderCallback callback = null;

	public void setEndpointRegistry(ESBEndpointRegistry registry) {
	}

	public void setProviderCallback(ESBProviderCallback callback) {
		this.callback = callback;
	}

	public ESBEndpointInfo getEndpoint() {
		return new ESBEndpointInfo() {
			private String uri = "http://localhost:8200/esb/AirportService";
			@SuppressWarnings("serial")
			private java.util.Map<String, Object> props = new java.util.HashMap<String, Object>() {
				{
					// "request-response" or "one-way"
					put("COMMUNICATION_STYLE", "request-response");
					//
					put("dataFormat", "PAYLOAD");
					// static
					put("portName", "{http://airportsoap.sopera.de}airportSoap");
					// default local part is: projectName + "_" + processName
					put("serviceName", "{http://airportsoap.sopera.de}airport");
					// static

					put("defaultOperationName",
							"getAirportInformationByISOCountryCode");
					// static
					put("defaultOperationNameSpace", "");
					// endpoint URI configured in tESBProviderInput
					put("publishedEndpointUrl", uri);
					// use Service Locator
					put("useServiceLocator", false);
					// use Service Activity Monitor
					put("useServiceActivityMonitor", false);

				}
			};

			public String getEndpointKey() {
				return "cxf";
			}

			public String getEndpointUri() {
				// projectName + "_" + processName
				return "TALEND_ESB_TUTORIAL_SimpleProvider";
				// return uri;
			}

			public java.util.Map<String, Object> getEndpointProperties() {
				return props;
			}
		};
	}

	public static class row3Struct implements
			routines.system.IPersistableRow<row3Struct> {
		final static byte[] commonByteArrayLock = new byte[0];
		static byte[] commonByteArray = new byte[0];

		public Document payload;

		public Document getPayload() {
			return this.payload;
		}

		public void readData(ObjectInputStream dis) {

			synchronized (commonByteArrayLock) {

				try {

					int length = 0;

					this.payload = (Document) dis.readObject();

				} catch (IOException e) {
					throw new RuntimeException(e);

				} catch (ClassNotFoundException eCNFE) {
					throw new RuntimeException(eCNFE);

				}

			}

		}

		public void writeData(ObjectOutputStream dos) {
			try {

				// Document

				dos.writeObject(this.payload);

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		public String toString() {

			StringBuilder sb = new StringBuilder();
			sb.append(super.toString());
			sb.append("[");
			sb.append("payload=" + String.valueOf(payload));
			sb.append("]");

			return sb.toString();
		}

		/**
		 * Compare keys
		 */
		public int compareTo(row3Struct other) {

			int returnValue = -1;

			return returnValue;
		}

		private int checkNullsAndCompare(Object object1, Object object2) {
			int returnValue = 0;
			if (object1 instanceof Comparable && object2 instanceof Comparable) {
				returnValue = ((Comparable) object1).compareTo(object2);
			} else if (object1 != null && object2 != null) {
				returnValue = compareStrings(object1.toString(), object2
						.toString());
			} else if (object1 == null && object2 != null) {
				returnValue = 1;
			} else if (object1 != null && object2 == null) {
				returnValue = -1;
			} else {
				returnValue = 0;
			}

			return returnValue;
		}

		private int compareStrings(String string1, String string2) {
			return string1.compareTo(string2);
		}

	}

	public static class request_XMLStruct implements
			routines.system.IPersistableRow<request_XMLStruct> {
		final static byte[] commonByteArrayLock = new byte[0];
		static byte[] commonByteArray = new byte[0];

		public Document payload;

		public Document getPayload() {
			return this.payload;
		}

		public void readData(ObjectInputStream dis) {

			synchronized (commonByteArrayLock) {

				try {

					int length = 0;

					this.payload = (Document) dis.readObject();

				} catch (IOException e) {
					throw new RuntimeException(e);

				} catch (ClassNotFoundException eCNFE) {
					throw new RuntimeException(eCNFE);

				}

			}

		}

		public void writeData(ObjectOutputStream dos) {
			try {

				// Document

				dos.writeObject(this.payload);

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		public String toString() {

			StringBuilder sb = new StringBuilder();
			sb.append(super.toString());
			sb.append("[");
			sb.append("payload=" + String.valueOf(payload));
			sb.append("]");

			return sb.toString();
		}

		/**
		 * Compare keys
		 */
		public int compareTo(request_XMLStruct other) {

			int returnValue = -1;

			return returnValue;
		}

		private int checkNullsAndCompare(Object object1, Object object2) {
			int returnValue = 0;
			if (object1 instanceof Comparable && object2 instanceof Comparable) {
				returnValue = ((Comparable) object1).compareTo(object2);
			} else if (object1 != null && object2 != null) {
				returnValue = compareStrings(object1.toString(), object2
						.toString());
			} else if (object1 == null && object2 != null) {
				returnValue = 1;
			} else if (object1 != null && object2 == null) {
				returnValue = -1;
			} else {
				returnValue = 0;
			}

			return returnValue;
		}

		private int compareStrings(String string1, String string2) {
			return string1.compareTo(string2);
		}

	}

	public static class row2Struct implements
			routines.system.IPersistableRow<row2Struct> {
		final static byte[] commonByteArrayLock = new byte[0];
		static byte[] commonByteArray = new byte[0];

		public Document payload;

		public Document getPayload() {
			return this.payload;
		}

		public void readData(ObjectInputStream dis) {

			synchronized (commonByteArrayLock) {

				try {

					int length = 0;

					this.payload = (Document) dis.readObject();

				} catch (IOException e) {
					throw new RuntimeException(e);

				} catch (ClassNotFoundException eCNFE) {
					throw new RuntimeException(eCNFE);

				}

			}

		}

		public void writeData(ObjectOutputStream dos) {
			try {

				// Document

				dos.writeObject(this.payload);

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		public String toString() {

			StringBuilder sb = new StringBuilder();
			sb.append(super.toString());
			sb.append("[");
			sb.append("payload=" + String.valueOf(payload));
			sb.append("]");

			return sb.toString();
		}

		/**
		 * Compare keys
		 */
		public int compareTo(row2Struct other) {

			int returnValue = -1;

			return returnValue;
		}

		private int checkNullsAndCompare(Object object1, Object object2) {
			int returnValue = 0;
			if (object1 instanceof Comparable && object2 instanceof Comparable) {
				returnValue = ((Comparable) object1).compareTo(object2);
			} else if (object1 != null && object2 != null) {
				returnValue = compareStrings(object1.toString(), object2
						.toString());
			} else if (object1 == null && object2 != null) {
				returnValue = 1;
			} else if (object1 != null && object2 == null) {
				returnValue = -1;
			} else {
				returnValue = 0;
			}

			return returnValue;
		}

		private int compareStrings(String string1, String string2) {
			return string1.compareTo(string2);
		}

	}

	public static class row1Struct implements
			routines.system.IPersistableRow<row1Struct> {
		final static byte[] commonByteArrayLock = new byte[0];
		static byte[] commonByteArray = new byte[0];

		public Document payload;

		public Document getPayload() {
			return this.payload;
		}

		public void readData(ObjectInputStream dis) {

			synchronized (commonByteArrayLock) {

				try {

					int length = 0;

					this.payload = (Document) dis.readObject();

				} catch (IOException e) {
					throw new RuntimeException(e);

				} catch (ClassNotFoundException eCNFE) {
					throw new RuntimeException(eCNFE);

				}

			}

		}

		public void writeData(ObjectOutputStream dos) {
			try {

				// Document

				dos.writeObject(this.payload);

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		public String toString() {

			StringBuilder sb = new StringBuilder();
			sb.append(super.toString());
			sb.append("[");
			sb.append("payload=" + String.valueOf(payload));
			sb.append("]");

			return sb.toString();
		}

		/**
		 * Compare keys
		 */
		public int compareTo(row1Struct other) {

			int returnValue = -1;

			return returnValue;
		}

		private int checkNullsAndCompare(Object object1, Object object2) {
			int returnValue = 0;
			if (object1 instanceof Comparable && object2 instanceof Comparable) {
				returnValue = ((Comparable) object1).compareTo(object2);
			} else if (object1 != null && object2 != null) {
				returnValue = compareStrings(object1.toString(), object2
						.toString());
			} else if (object1 == null && object2 != null) {
				returnValue = 1;
			} else if (object1 != null && object2 == null) {
				returnValue = -1;
			} else {
				returnValue = 0;
			}

			return returnValue;
		}

		private int compareStrings(String string1, String string2) {
			return string1.compareTo(string2);
		}

	}

	public static class after_tESBProviderRequest_1Struct implements
			routines.system.IPersistableRow<after_tESBProviderRequest_1Struct> {
		final static byte[] commonByteArrayLock = new byte[0];
		static byte[] commonByteArray = new byte[0];

		public Document payload;

		public Document getPayload() {
			return this.payload;
		}

		public void readData(ObjectInputStream dis) {

			synchronized (commonByteArrayLock) {

				try {

					int length = 0;

					this.payload = (Document) dis.readObject();

				} catch (IOException e) {
					throw new RuntimeException(e);

				} catch (ClassNotFoundException eCNFE) {
					throw new RuntimeException(eCNFE);

				}

			}

		}

		public void writeData(ObjectOutputStream dos) {
			try {

				// Document

				dos.writeObject(this.payload);

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		public String toString() {

			StringBuilder sb = new StringBuilder();
			sb.append(super.toString());
			sb.append("[");
			sb.append("payload=" + String.valueOf(payload));
			sb.append("]");

			return sb.toString();
		}

		/**
		 * Compare keys
		 */
		public int compareTo(after_tESBProviderRequest_1Struct other) {

			int returnValue = -1;

			return returnValue;
		}

		private int checkNullsAndCompare(Object object1, Object object2) {
			int returnValue = 0;
			if (object1 instanceof Comparable && object2 instanceof Comparable) {
				returnValue = ((Comparable) object1).compareTo(object2);
			} else if (object1 != null && object2 != null) {
				returnValue = compareStrings(object1.toString(), object2
						.toString());
			} else if (object1 == null && object2 != null) {
				returnValue = 1;
			} else if (object1 != null && object2 == null) {
				returnValue = -1;
			} else {
				returnValue = 0;
			}

			return returnValue;
		}

		private int compareStrings(String string1, String string2) {
			return string1.compareTo(string2);
		}

	}

	public void tESBProviderRequest_1Process(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tESBProviderRequest_1_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				tFileInputDelimited_1Process(globalMap);

				row1Struct row1 = new row1Struct();
				row1Struct row2 = row1;
				request_XMLStruct request_XML = new request_XMLStruct();
				request_XMLStruct row3 = request_XML;

				/**
				 * [tESBProviderResponse_1 begin ] start
				 */

				ok_Hash.put("tESBProviderResponse_1", false);
				start_Hash.put("tESBProviderResponse_1", System
						.currentTimeMillis());
				currentComponent = "tESBProviderResponse_1";

				int tos_count_tESBProviderResponse_1 = 0;

				/**
				 * [tESBProviderResponse_1 begin ] stop
				 */

				/**
				 * [tLogRow_3 begin ] start
				 */

				ok_Hash.put("tLogRow_3", false);
				start_Hash.put("tLogRow_3", System.currentTimeMillis());
				currentComponent = "tLogRow_3";

				int tos_count_tLogRow_3 = 0;

				// /////////////////////

				final String OUTPUT_FIELD_SEPARATOR_tLogRow_3 = "|";
				java.io.PrintStream consoleOut_tLogRow_3 = null;

				StringBuilder strBuffer_tLogRow_3 = null;
				int nb_line_tLogRow_3 = 0;
				// /////////////////////

				/**
				 * [tLogRow_3 begin ] stop
				 */

				/**
				 * [tXMLMap_1 begin ] start
				 */

				ok_Hash.put("tXMLMap_1", false);
				start_Hash.put("tXMLMap_1", System.currentTimeMillis());
				currentComponent = "tXMLMap_1";

				int tos_count_tXMLMap_1 = 0;

				org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<row5Struct> tHash_Lookup_row5 = (org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<row5Struct>) ((org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<row5Struct>) globalMap
						.get("tHash_Lookup_row5"));

				row5Struct row5HashKey = new row5Struct();
				row5Struct row5Default = new row5Struct();
				row5Struct row5 = new row5Struct();

				// ===============================input xml init
				// part===============================

				class NameSpaceTool_tXMLMap_1 {

					public java.util.HashMap<String, String> xmlNameSpaceMap = new java.util.HashMap<String, String>();

					private java.util.List<String> defualtNSPath = new java.util.ArrayList<String>();

					public void countNSMap(org.dom4j.Element el) {
						for (org.dom4j.Namespace ns : (java.util.List<org.dom4j.Namespace>) el
								.declaredNamespaces()) {
							if (ns.getPrefix().trim().length() == 0) {
								xmlNameSpaceMap.put("pre"
										+ defualtNSPath.size(), ns.getURI());
								String path = "";
								org.dom4j.Element elTmp = el;
								while (elTmp != null) {
									if (elTmp.getNamespacePrefix() != null
											&& elTmp.getNamespacePrefix()
													.length() > 0) {
										path = "/" + elTmp.getNamespacePrefix()
												+ ":" + elTmp.getName() + path;
									} else {
										path = "/" + elTmp.getName() + path;
									}
									elTmp = elTmp.getParent();
								}
								defualtNSPath.add(path);
							} else {
								xmlNameSpaceMap
										.put(ns.getPrefix(), ns.getURI());
							}

						}
						for (org.dom4j.Element e : (java.util.List<org.dom4j.Element>) el
								.elements()) {
							countNSMap(e);
						}
					}

					public String addDefaultNSPrefix(String path,
							String loopPath) {
						if (defualtNSPath.size() > 0) {
							String fullPath = loopPath;
							if (!path.equals(fullPath)) {
								for (String tmp : path.split("/")) {
									if (("..").equals(tmp)) {
										fullPath = fullPath.substring(0,
												fullPath.lastIndexOf("/"));
									} else {
										fullPath += "/" + tmp;
									}
								}
							}
							int[] indexs = new int[fullPath.split("/").length - 1];
							java.util.Arrays.fill(indexs, -1);
							int length = 0;
							for (int i = 0; i < defualtNSPath.size(); i++) {
								if (defualtNSPath.get(i).length() > length
										&& fullPath.startsWith(defualtNSPath
												.get(i))) {
									java.util.Arrays.fill(indexs, defualtNSPath
											.get(i).split("/").length - 2,
											indexs.length, i);
									length = defualtNSPath.get(i).length();
								}
							}

							StringBuilder newPath = new StringBuilder();
							String[] pathStrs = path.split("/");
							for (int i = 0; i < pathStrs.length; i++) {
								String tmp = pathStrs[i];
								if (newPath.length() > 0) {
									newPath.append("/");
								}
								if (tmp.length() > 0 && tmp.indexOf(":") == -1
										&& tmp.indexOf(".") == -1 /*
																 * &&
																 * tmp.indexOf
																 * ("@") == -1
																 */) {
									int index = indexs[i + indexs.length
											- pathStrs.length];
									if (index >= 0) {
										// ==== add by wliu to support both
										// filter and functions==
										if (tmp.indexOf("[") > 0
												&& tmp.indexOf("]") > tmp
														.indexOf("[")) {// include
																		// filter
											String tmpStr = replaceElementWithNS(
													tmp, "pre" + index + ":");
											newPath.append(tmpStr);
										} else {
											if (tmp.indexOf("@") != -1
													|| tmp.indexOf("(") < tmp
															.indexOf(")")) { // include
																				// attribute
												newPath.append(tmp);
											} else {
												// ==add end=======
												newPath.append("pre").append(
														index).append(":")
														.append(tmp);
											}
										}
									} else {
										newPath.append(tmp);
									}
								} else {
									newPath.append(tmp);
								}
							}
							return newPath.toString();
						}
						return path;
					}

					private String matches = "@*\\b[a-z|A-Z|_]+[[-]*\\w]*\\b[^'|^\\(]";
					private java.util.regex.Pattern pattern = java.util.regex.Pattern
							.compile(matches);

					private String replaceElementWithNS(String global,
							String pre) {

						java.util.regex.Matcher match = pattern.matcher(global);
						StringBuffer sb = new StringBuffer();
						match.reset();
						while (match.find()) {
							String group = match.group();
							String tmp = "";
							if (group.toLowerCase().matches(
									"\\b(div|mod|and|or)\\b.*")
									|| group.matches("@.*")) {
								tmp = group;
							} else {
								tmp = tmp + pre + group;
							}
							match.appendReplacement(sb, tmp);
						}
						match.appendTail(sb);

						return sb.toString();
					}

				}

				class XML_API_tXMLMap_1 {
					public boolean isDefNull(org.dom4j.Node node)
							throws javax.xml.transform.TransformerException {
						if (node != null && node instanceof org.dom4j.Element) {
							org.dom4j.Attribute attri = ((org.dom4j.Element) node)
									.attribute("nil");
							if (attri != null
									&& ("true").equals(attri.getText())) {
								return true;
							}
						}
						return false;
					}

					public boolean isMissing(org.dom4j.Node node)
							throws javax.xml.transform.TransformerException {
						return node == null ? true : false;
					}

					public boolean isEmpty(org.dom4j.Node node)
							throws javax.xml.transform.TransformerException {
						if (node != null) {
							return node.getText().length() == 0;
						}
						return false;
					}
				}
				class Var__tXMLMap_1__Struct {
				}
				Var__tXMLMap_1__Struct Var__tXMLMap_1 = new Var__tXMLMap_1__Struct();
				// ###############################
				// # Outputs initialization
				request_XMLStruct request_XML_tmp = new request_XMLStruct();
				request_XMLStruct request_XML_save = new request_XMLStruct();
				// ###############################
				class TreeNode_API_tXMLMap_1 {
					java.util.Map<String, String> xpath_value_map = new java.util.HashMap<String, String>();

					void clear() {
						xpath_value_map.clear();
					}

					void put(String xpath, String value) {
						xpath_value_map.put(xpath, value);
					}

					String get_null(String xpath) {
						return null;
					}

					String get_String(String xpath) {
						return xpath_value_map.get(xpath);
					}
				}
				TreeNode_API_tXMLMap_1 treeNodeAPI_tXMLMap_1 = new TreeNode_API_tXMLMap_1();
				NameSpaceTool_tXMLMap_1 nsTool_tXMLMap_1 = new NameSpaceTool_tXMLMap_1();
				int nb_line_tXMLMap_1 = 0;

				XML_API_tXMLMap_1 xml_api_tXMLMap_1 = new XML_API_tXMLMap_1();

				class NestXMLTool_tXMLMap_1 {
					public void parseAndAdd(org.dom4j.Element nestRoot,
							String value) {
						try {
							org.dom4j.Document doc4Str = org.dom4j.DocumentHelper
									.parseText("<root>" + value + "</root>");
							nestRoot.setContent(doc4Str.getRootElement()
									.content());
						} catch (Exception e) {
							e.printStackTrace();
							nestRoot.setText(value);
						}
					}

					public void setText(org.dom4j.Element element, String value) {
						if (value.startsWith("<![CDATA[")
								&& value.endsWith("]]>")) {
							String text = value
									.substring(9, value.length() - 3);
							element.addCDATA(text);
						} else {
							element.setText(value);
						}
					}

					public void replaceDefaultNameSpace(
							org.dom4j.Element nestRoot) {
						if (nestRoot != null) {
							for (org.dom4j.Element tmp : (java.util.List<org.dom4j.Element>) nestRoot
									.elements()) {
								if (("").equals(tmp.getQName().getNamespace()
										.getURI())
										&& ("").equals(tmp.getQName()
												.getNamespace().getPrefix())) {
									tmp.setQName(org.dom4j.DocumentHelper
											.createQName(tmp.getName(),
													nestRoot.getQName()
															.getNamespace()));
								}
								replaceDefaultNameSpace(tmp);
							}
						}
					}

					public void removeEmptyElement(org.dom4j.Element root) {
						if (root != null) {
							for (org.dom4j.Element tmp : (java.util.List<org.dom4j.Element>) root
									.elements()) {
								removeEmptyElement(tmp);
							}
							if (root.content().size() == 0
									&& root.attributes().size() == 0
									&& root.declaredNamespaces().size() == 0) {
								if (root.getParent() != null) {
									root.getParent().remove(root);
								}
							}
						}
					}
				}
				// NestXMLTool_tXMLMap_1 nestXMLTool_tXMLMap_1 = new
				// NestXMLTool_tXMLMap_1();

				class GenerateDocument_request_XML {

					TreeNode_API_tXMLMap_1 treeNodeAPI = null;

					org.dom4j.Document doc = null;

					NestXMLTool_tXMLMap_1 nestXMLTool = null;

					org.dom4j.Element root4Group = null;

					org.dom4j.io.OutputFormat format = null;

					java.util.List<java.util.List<String>> groupbyList = null;
					java.util.List<org.dom4j.Element> groupElementList = null;
					int order = 0;

					boolean isFirst = true;

					boolean needRoot = true;

					public GenerateDocument_request_XML() {
						// this.treeNodeAPI = treeNodeAPI;

						nestXMLTool = new NestXMLTool_tXMLMap_1();

						groupbyList = new java.util.ArrayList<java.util.List<String>>();
						groupElementList = new java.util.ArrayList<org.dom4j.Element>();

						doc = org.dom4j.DocumentHelper.createDocument();
						format = org.dom4j.io.OutputFormat.createPrettyPrint();
						format.setTrimText(false);
					}

					public org.dom4j.Document getDocument() {
						return this.doc;
					}

					// We generate the TreeNode_API object only if there is a
					// document in the main input table.
					void generateElements(TreeNode_API_tXMLMap_1 treeNodeAPI,
							boolean isInnerJoin, row1Struct row2,
							row5Struct row5, Var__tXMLMap_1__Struct Var) {

						/*
						 * if(this.treeNodeAPI==null) { this.treeNodeAPI =
						 * treeNodeAPI; }
						 */

						org.dom4j.Element subTreeRootParent = null;
						// build root xml tree
						if (needRoot) {
							needRoot = false;
							org.dom4j.Element root = doc
									.addElement("air:getAirportInformationByISOCountryCodeResponse");

							subTreeRootParent = root;
							root.addNamespace(
									"air",
									TalendString
											.replaceSpecialCharForXML("http://airportsoap.sopera.de"));
							root.setQName(org.dom4j.DocumentHelper
									.createQName(
											"getAirportInformationByISOCountryCodeResponse",
											org.dom4j.DocumentHelper
													.createNamespace(
															"air",
															TalendString
																	.replaceSpecialCharForXML("http://airportsoap.sopera.de"))));
							root4Group = subTreeRootParent;
						} else {
							subTreeRootParent = root4Group;
						}
						/* build group xml tree */
						boolean isNewElement = false;
						isNewElement = false;
						org.dom4j.Element loop;
						if (subTreeRootParent.getNamespaceForPrefix("air") == null) {
							loop = subTreeRootParent
									.addElement("getAirportInformationByISOCountryCodeResult");
						} else {
							loop = subTreeRootParent
									.addElement("air:getAirportInformationByISOCountryCodeResult");
						}

						subTreeRootParent = loop;
						nestXMLTool.setText(loop, String
								.valueOf(row5.airportsInformations));
					}
				}

				/**
				 * [tXMLMap_1 begin ] stop
				 */

				/**
				 * [tLogRow_1 begin ] start
				 */

				ok_Hash.put("tLogRow_1", false);
				start_Hash.put("tLogRow_1", System.currentTimeMillis());
				currentComponent = "tLogRow_1";

				int tos_count_tLogRow_1 = 0;

				// /////////////////////

				final String OUTPUT_FIELD_SEPARATOR_tLogRow_1 = "|";
				java.io.PrintStream consoleOut_tLogRow_1 = null;

				StringBuilder strBuffer_tLogRow_1 = null;
				int nb_line_tLogRow_1 = 0;
				// /////////////////////

				/**
				 * [tLogRow_1 begin ] stop
				 */

				/**
				 * [tESBProviderRequest_1 begin ] start
				 */

				ok_Hash.put("tESBProviderRequest_1", false);
				start_Hash.put("tESBProviderRequest_1", System
						.currentTimeMillis());
				currentComponent = "tESBProviderRequest_1";

				int tos_count_tESBProviderRequest_1 = 0;

				/**
				 * queued message exchange
				 */
				class QueuedExchangeContextImpl<T> {

					/**
					 * Exchange timeout in seconds
					 */
					private static final long EXCHANGE_TIMEOUT = 50;

					private final java.util.concurrent.Exchanger<Exception> exceptionExchange = new java.util.concurrent.Exchanger<Exception>();
					private final java.util.concurrent.CountDownLatch latch = new java.util.concurrent.CountDownLatch(
							1);

					private final T input;

					private T output = null;
					// private T faultDetails = null;
					private Throwable fault = null;

					// private String faultMessage = null;

					public QueuedExchangeContextImpl(T inMsg) {
						this.input = inMsg;
					}

					/**
					 * Don't forget to call this method when you are done with
					 * processing of the {@link QueuedExchangeContext}
					 */
					public void release() throws Exception {
						latch.countDown();
						Exception exception;
						try {
							exception = exceptionExchange.exchange(null,
									EXCHANGE_TIMEOUT,
									java.util.concurrent.TimeUnit.SECONDS);
						} catch (InterruptedException e) {
							throw new Exception(e);
						} catch (java.util.concurrent.TimeoutException e) {
							throw new Exception(e);
						}
						if (exception != null) {
							throw exception;
						}
					}

					/**
					 * This operation have to be called on the Web Service
					 * thread to send response if required
					 * 
					 * @throws InterruptedException
					 */
					public void completeQueuedProcessing()
							throws InterruptedException {
						exceptionExchange.exchange(null);
					}

					/**
					 * @throws InterruptedException
					 */
					void waitForRelease(long timeout,
							java.util.concurrent.TimeUnit unit)
							throws InterruptedException {
						latch.await(timeout, unit);
					}

					public T getInputMessage() {
						return input;
					}

					public void serveOutputMessage(T response) {
						output = response;
					}

					// public void serveBusinessFault(String faultMessage, T
					// faultDetails) {
					// this.faultMessage =
					// (null == faultMessage || 0 ==
					// faultMessage.trim().length())
					// ? "Talend job business fault" : faultMessage;
					// this.faultDetails = faultDetails;
					// }
					//
					// public void serveFault(String faultMessage, Throwable
					// fault) {
					// this.faultMessage =
					// (null == faultMessage || 0 ==
					// faultMessage.trim().length())
					// ? "Talend job error" : faultMessage;
					// this.fault = fault;
					// }

					public void serveFault(Throwable fault) {
						this.fault = fault;
					}

					public boolean isFault() {
						// return (faultMessage != null);
						return fault != null;
					}

					// public boolean isBusinessFault() {
					// return isFault() && null == fault;
					// }

					public T getResponse() {
						return output;
					}

					// public String getFaultMessage() {
					// return faultMessage;
					// }
					//
					// public T getBusinessFaultDetails() {
					// return faultDetails;
					// }

					public Throwable getFault() {
						return fault;
					}

				}

				/**
				 * message exchange controller
				 */
				class QueuedMessageHandlerImpl<T> implements
						ESBProviderCallback {
					private final int MAX_QUEUE_SIZE = 1000;

					private final int WAIT_TIMEOUT_SECONDS = 120;

					private final java.util.concurrent.BlockingQueue<QueuedExchangeContextImpl<?>> queue = new java.util.concurrent.LinkedBlockingQueue<QueuedExchangeContextImpl<?>>(
							MAX_QUEUE_SIZE);

					/**
					 * This method add a newly created
					 * {@link QueuedExchangeContextImpl} into the internal
					 * blocking queue where consumer thread is waiting for it.
					 * Then it waits until the {@link QueuedExchangeContextImpl}
					 * will be completed for request-response operations
					 */
					public QueuedExchangeContextImpl<T> invoke(T request) {
						QueuedExchangeContextImpl<T> context = new QueuedExchangeContextImpl<T>(
								request);
						boolean inserted = queue.offer(context);
						if (!inserted) {
							try {
								context.release();
							} catch (Exception e) {
								e.printStackTrace();
							}
							// context.serveFault("job pool overflow exceed",
							// null);
							throw new RuntimeException(
									"Can't queue request, queue size of "
											+ MAX_QUEUE_SIZE + " is exceeded");
						} else {
							try {
								context.waitForRelease(WAIT_TIMEOUT_SECONDS,
										java.util.concurrent.TimeUnit.SECONDS);
							} catch (InterruptedException ie) {
								// context.serveFault("job execution timeout",
								// ie);
								throw new RuntimeException(
										"job execution timeout: "
												+ ie.getMessage());
							}
						}
						return context;
					}

					QueuedExchangeContextImpl<T> currentExchangeContext;

					public T getRequest() throws ESBJobInterruptedException {
						currentExchangeContext = null;
						try {
							currentExchangeContext = (QueuedExchangeContextImpl<T>) queue
									.take();
						} catch (InterruptedException e) {
							// e.printStackTrace();
							throw new RuntimeException(e);
						}
						return currentExchangeContext.getInputMessage();
					}

					public void sendResponse(Object output) {
						if (null == currentExchangeContext) {
							throw new RuntimeException(
									"sendResponse() invoked before getRequest()");
						}

						// // business fault
						// if (output instanceof ProviderFault) {
						// ProviderFault providerFault = (ProviderFault) output;
						// currentExchangeContext.serveBusinessFault(
						// providerFault.getMessage(), (T)
						// providerFault.getDetail());
						// }
						//
						// // job error
						// if (output instanceof Exception) {
						// currentExchangeContext.serveFault(
						// "Talend job execution error", (Throwable) output);
						// }
						//
						// // payload
						// currentExchangeContext.serveOutputMessage((T)
						// output);

						if (output instanceof Throwable) {
							// fault
							currentExchangeContext
									.serveFault((Throwable) output);
						} else {
							// response
							currentExchangeContext
									.serveOutputMessage((T) output);
						}

						try {
							currentExchangeContext.release();
						} catch (Exception e) {
							// e.printStackTrace();
							throw new RuntimeException(e);
						}
					}
				}

				/**
				 * web service provider implementation
				 */
				@javax.jws.WebService(name = "airport", targetNamespace = "http://airportsoap.sopera.de")
				@javax.jws.soap.SOAPBinding(parameterStyle = javax.jws.soap.SOAPBinding.ParameterStyle.BARE)
				@javax.xml.ws.ServiceMode(value = javax.xml.ws.Service.Mode.PAYLOAD)
				@javax.xml.ws.WebServiceProvider()
				class ESBProvider_tESBProviderRequest_1 implements
						javax.xml.ws.Provider<javax.xml.transform.Source> {

					private javax.xml.transform.TransformerFactory factory = javax.xml.transform.TransformerFactory
							.newInstance();
					private QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler;

					private final String TNS = ESBProvider_tESBProviderRequest_1.class
							.getAnnotation(javax.jws.WebService.class)
							.targetNamespace();

					public ESBProvider_tESBProviderRequest_1(
							QueuedMessageHandlerImpl<org.dom4j.Document> messageHandler) {
						this.messageHandler = messageHandler;
					}

					@javax.jws.WebMethod(operationName = "getAirportInformationByISOCountryCode", action = "http://airportsoap.sopera.de/getAirportInformationByISOCountryCode")
					@javax.jws.WebResult(name = "getAirportInformationByISOCountryCodeOutput", targetNamespace = "http://airportsoap.sopera.de", partName = "response")
					public javax.xml.transform.Source invoke(
							@javax.jws.WebParam(name = "getAirportInformationByISOCountryCodeInput", targetNamespace = "http://airportsoap.sopera.de", partName = "request") javax.xml.transform.Source request) {

						// System.out.println(System.currentTimeMillis() +
						// " -> handleMessage");

						try {
							org.dom4j.io.DocumentResult docResult = new org.dom4j.io.DocumentResult();
							factory.newTransformer().transform(request,
									docResult);
							org.dom4j.Document requestDoc = docResult
									.getDocument();
							// System.out.println("request: " +
							// requestDoc.asXML());

							QueuedExchangeContextImpl<org.dom4j.Document> messageExchange = messageHandler
									.invoke(requestDoc);

							try {
								if (messageExchange.isFault()) {
									throw messageExchange.getFault();

									// String faultString =
									// messageExchange.getFaultMessage();
									// // System.out.println("fault: " +
									// faultString);
									//
									// if (messageExchange.isBusinessFault()) {
									// org.dom4j.Document faultDoc =
									// messageExchange.getBusinessFaultDetails();
									// javax.xml.soap.SOAPFactory soapFactory =
									// javax.xml.soap.SOAPFactory.newInstance();
									// javax.xml.soap.SOAPFault soapFault =
									// soapFactory.createFault(faultString,
									// new javax.xml.namespace.QName(TNS,
									// "businessFault"));
									// if (null != faultDoc) {
									// //
									// System.out.println("business fault details: "
									// + faultDoc.asXML());
									// org.dom4j.io.DOMWriter writer = new
									// org.dom4j.io.DOMWriter();
									// org.w3c.dom.Document faultDetailDom =
									// writer.write(faultDoc);
									// soapFault.addDetail().appendChild(
									// soapFault.getOwnerDocument().importNode(
									// faultDetailDom.getDocumentElement(),
									// true));
									// }
									// throw new
									// javax.xml.ws.soap.SOAPFaultException(soapFault);
									// } else {
									// Throwable error =
									// messageExchange.getFault();
									// // System.out.println("job error: " +
									// error.getMessage());
									// if (error instanceof RuntimeException) {
									// throw (RuntimeException) error;
									// } else {
									// throw new RuntimeException(faultString,
									// error);
									// }
									// }
								} else {
									org.dom4j.Document responseDoc = messageExchange
											.getResponse();
									if (null == responseDoc) {
										// System.out.println("response: empty");
										throw new RuntimeException(
												"no response provided by Talend job");
									}
									// System.out.println("response: " +
									// responseDoc.asXML());

									return new org.dom4j.io.DocumentSource(
											responseDoc);
								}
							} finally {
								messageExchange.completeQueuedProcessing();
							}

						} catch (RuntimeException ex) {
							throw ex;
						} catch (Throwable ex) {
							ex.printStackTrace();
							throw new RuntimeException(ex);
						} finally {
							// System.out.println(System.currentTimeMillis() +
							// " <- handleMessage");
						}
					}
				}

				class ESBProviderCallbackTalendJobWrapper_tESBProviderRequest_1
						implements ESBProviderCallbackTalendJobInner {

					private final String TNS = ESBProvider_tESBProviderRequest_1.class
							.getAnnotation(javax.jws.WebService.class)
							.targetNamespace();

					private ESBProviderCallback esbProviderCallback;

					public ESBProviderCallbackTalendJobWrapper_tESBProviderRequest_1(
							ESBProviderCallback callback) {
						esbProviderCallback = callback;
					}

					public Object getRequest()
							throws ESBJobInterruptedException {
						return esbProviderCallback.getRequest();
					}

					public void sendResponse(Object response) {
						esbProviderCallback.sendResponse(response);
					}

					public void sendFault(Throwable error) {
						RuntimeException talendJobError;
						if (error instanceof RuntimeException) {
							talendJobError = (RuntimeException) error;
						} else {
							talendJobError = new RuntimeException(
									"Talend job execution error", error);
						}
						esbProviderCallback.sendResponse(talendJobError);
					}

					public void sendBusinessFault(String faultString,
							org.dom4j.Document faultDetail) {

						try {
							javax.xml.soap.SOAPFactory soapFactory = javax.xml.soap.SOAPFactory
									.newInstance();
							javax.xml.soap.SOAPFault soapFault = soapFactory
									.createFault(faultString,
											new javax.xml.namespace.QName(TNS,
													"businessFault"));
							if (null != faultDetail) {
								// System.out.println("business fault details: "
								// + faultDoc.asXML());
								// A special version of DOMWriter that does not
								// write xmlns:foo attributes
								org.dom4j.io.DOMWriter writer = new org.dom4j.io.DOMWriter() {
									protected void writeNamespace(
											org.w3c.dom.Element domElement,
											org.dom4j.Namespace namespace) {
										// Do nothing
									}
								};
								org.w3c.dom.Document faultDetailDom = writer
										.write(faultDetail);
								soapFault
										.addDetail()
										.appendChild(
												soapFault
														.getOwnerDocument()
														.importNode(
																faultDetailDom
																		.getDocumentElement(),
																true));
							}
							esbProviderCallback
									.sendResponse(new javax.xml.ws.soap.SOAPFaultException(
											soapFault));
						} catch (Exception e) {
							this.sendFault(e);
						}
					}
				}

				class HandlerThread_tESBProviderRequest_1 extends Thread {

					private final String TNS = ESBProvider_tESBProviderRequest_1.class
							.getAnnotation(javax.jws.WebService.class)
							.targetNamespace();

					private javax.xml.ws.Endpoint endpoint;
					QueuedMessageHandlerImpl<org.dom4j.Document> handler;

					final String endpointUrl = "http://localhost:8200/esb/AirportService";

					public HandlerThread_tESBProviderRequest_1(
							QueuedMessageHandlerImpl<org.dom4j.Document> handler) {
						this.handler = handler;
					}

					public void run() {
						ESBProvider_tESBProviderRequest_1 esbProvider = new ESBProvider_tESBProviderRequest_1(
								handler);

						endpoint = javax.xml.ws.Endpoint.create(esbProvider);
						@SuppressWarnings("serial")
						java.util.Map<String, Object> map = new java.util.HashMap<String, Object>() {
							{
								put(javax.xml.ws.Endpoint.WSDL_SERVICE,
										new javax.xml.namespace.QName(TNS,
												"airport"));
								put(javax.xml.ws.Endpoint.WSDL_PORT,
										new javax.xml.namespace.QName(TNS,
												"airportSoap")); //
							}
						};
						endpoint.setProperties(map);
						// test for busy
						java.net.ServerSocket ss = null;
						try {
							java.net.URL endpointURL = new java.net.URL(
									endpointUrl);
							String host = endpointURL.getHost();
							int port = endpointURL.getPort();
							if ("localhost".equals(host)
									|| host.startsWith("127.0.0")) {
								try {
									ss = new java.net.ServerSocket(port);
								} catch (IOException e) {
									throw new IllegalArgumentException(
											"Cannot start provider with uri: "
													+ endpointUrl + ". Port "
													+ port + " already in use."); // rethrow
																					// exception
								} finally {
									if (ss != null) {
										try {
											ss.close();
										} catch (IOException e) {
											// ignore
										}
									}
								}
								try {
									// ok, let's doublecheck for silent
									// listeners
									java.net.Socket cs = new java.net.Socket(
											host, port);
									// if succeed - somebody silently listening,
									// fail!
									cs.close();
									throw new IllegalArgumentException(
											"Cannot start provider with uri: "
													+ endpointUrl + ". Port "
													+ port + " already in use."); // rethrow
																					// exception
								} catch (IOException e) {
									// ok, nobody listens, proceed
								}
							}
						} catch (java.net.MalformedURLException e) {
							throw new IllegalArgumentException(
									"Cannot start provider with uri: "
											+ endpointUrl + ". Malformed URL."); // rethrow
																					// exception
						}
						endpoint.publish(endpointUrl);

						System.out.println("web service [endpoint: "
								+ endpointUrl + "] published");
					}

					public void stopEndpoint() {
						if (null != endpoint) {
							endpoint.stop();
							System.out.println("web service [endpoint: "
									+ endpointUrl + "] unpublished");
						}
					}
				}

				// *** external processor(s) initialization
				ESBProviderCallbackTalendJobInner providerCallback_tESBProviderRequest_1;
				HandlerThread_tESBProviderRequest_1 handlerThread_tESBProviderRequest_1 = null;
				if (null == this.callback) {
					final QueuedMessageHandlerImpl<org.dom4j.Document> handler_tESBProviderRequest_1 = new QueuedMessageHandlerImpl<org.dom4j.Document>();
					handlerThread_tESBProviderRequest_1 = new HandlerThread_tESBProviderRequest_1(
							handler_tESBProviderRequest_1); //
					handlerThread_tESBProviderRequest_1.start();
					providerCallback_tESBProviderRequest_1 = new ESBProviderCallbackTalendJobWrapper_tESBProviderRequest_1(
							handler_tESBProviderRequest_1);
				} else {
					providerCallback_tESBProviderRequest_1 = new ESBProviderCallbackTalendJobWrapper_tESBProviderRequest_1(
							this.callback);
				}

				globalMap.put("esbHandler",
						providerCallback_tESBProviderRequest_1);
				// *** external processor(s) initialization finish

				int nb_line_tESBProviderRequest_1 = 0;

				try {
					// This is a beginning of the ESB provider request component
					// cycle
					while (true) {
						try {

							/**
							 * [tESBProviderRequest_1 begin ] stop
							 */
							/**
							 * [tESBProviderRequest_1 main ] start
							 */

							currentComponent = "tESBProviderRequest_1";

							ESBProviderCallbackTalendJobInner esbHandler_tESBProviderRequest_1 = (ESBProviderCallbackTalendJobInner) globalMap
									.get("esbHandler");

							org.dom4j.Document requestMessage_tESBProviderRequest_1 = (org.dom4j.Document) esbHandler_tESBProviderRequest_1
									.getRequest();

							Document talendDocument_tESBProviderRequest_1 = new Document();
							talendDocument_tESBProviderRequest_1
									.setDocument(requestMessage_tESBProviderRequest_1);
							row1.payload = talendDocument_tESBProviderRequest_1;

							tos_count_tESBProviderRequest_1++;

							/**
							 * [tESBProviderRequest_1 main ] stop
							 */

							/**
							 * [tLogRow_1 main ] start
							 */

							currentComponent = "tLogRow_1";

							// /////////////////////

							strBuffer_tLogRow_1 = new StringBuilder();

							if (row1.payload != null) { //

								strBuffer_tLogRow_1.append(String
										.valueOf(row1.payload));

							} //

							if (globalMap.get("tLogRow_CONSOLE") != null) {
								consoleOut_tLogRow_1 = (java.io.PrintStream) globalMap
										.get("tLogRow_CONSOLE");
							} else {
								consoleOut_tLogRow_1 = new java.io.PrintStream(
										new java.io.BufferedOutputStream(
												System.out));
								globalMap.put("tLogRow_CONSOLE",
										consoleOut_tLogRow_1);
							}

							consoleOut_tLogRow_1.println(strBuffer_tLogRow_1
									.toString());
							consoleOut_tLogRow_1.flush();
							nb_line_tLogRow_1++;
							// ////

							// ////

							// /////////////////////

							row2 = row1;

							tos_count_tLogRow_1++;

							/**
							 * [tLogRow_1 main ] stop
							 */

							/**
							 * [tXMLMap_1 main ] start
							 */

							currentComponent = "tXMLMap_1";

							boolean rejectedInnerJoin_tXMLMap_1 = false;
							boolean rejectedDocInnerJoin_tXMLMap_1 = false;
							boolean mainRowRejected_tXMLMap_1 = false;

							GenerateDocument_request_XML gen_Doc_request_XML_tXMLMap_1 = new GenerateDocument_request_XML();
							request_XML_tmp.payload = null;
							String xPathLoop_tXMLMap_1 = "/air:getAirportInformationByISOCountryCode/air:CountryAbbrviation";
							org.dom4j.Document doc_tXMLMap_1 = row2.payload
									.getDocument();
							nsTool_tXMLMap_1.countNSMap(doc_tXMLMap_1
									.getRootElement());
							java.util.HashMap<String, String> xmlNameSpaceMap_tXMLMap_1 = nsTool_tXMLMap_1.xmlNameSpaceMap;
							org.dom4j.XPath x_tXMLMap_1 = doc_tXMLMap_1
									.createXPath(nsTool_tXMLMap_1
											.addDefaultNSPrefix(
													xPathLoop_tXMLMap_1,
													xPathLoop_tXMLMap_1));
							x_tXMLMap_1
									.setNamespaceURIs(xmlNameSpaceMap_tXMLMap_1);

							java.util.List<org.dom4j.tree.AbstractNode> nodeList_tXMLMap_1 = (java.util.List<org.dom4j.tree.AbstractNode>) x_tXMLMap_1
									.selectNodes(doc_tXMLMap_1);
							String str_tXMLMap_1 = null;
							org.dom4j.Node node_tXMLMap_1 = null;

							for (org.dom4j.tree.AbstractNode temp_tXMLMap_1 : nodeList_tXMLMap_1) { // G_TXM_M_001
								nb_line_tXMLMap_1++;
								rejectedDocInnerJoin_tXMLMap_1 = false;
								mainRowRejected_tXMLMap_1 = false;

								treeNodeAPI_tXMLMap_1.clear();
								org.dom4j.XPath xTmp0_tXMLMap_1 = temp_tXMLMap_1
										.createXPath(nsTool_tXMLMap_1
												.addDefaultNSPrefix(".",
														xPathLoop_tXMLMap_1));
								xTmp0_tXMLMap_1
										.setNamespaceURIs(xmlNameSpaceMap_tXMLMap_1);
								Object obj0_tXMLMap_1 = xTmp0_tXMLMap_1
										.evaluate(temp_tXMLMap_1);
								if (obj0_tXMLMap_1 instanceof String
										|| obj0_tXMLMap_1 instanceof Number) {
									str_tXMLMap_1 = String
											.valueOf(obj0_tXMLMap_1);
								} else {
									node_tXMLMap_1 = xTmp0_tXMLMap_1
											.selectSingleNode(temp_tXMLMap_1);
									str_tXMLMap_1 = xTmp0_tXMLMap_1
											.valueOf(temp_tXMLMap_1);
								}
								treeNodeAPI_tXMLMap_1
										.put(
												"row2.payload:/air:getAirportInformationByISOCountryCode/air:CountryAbbrviation",
												str_tXMLMap_1);

								// /////////////////////////////////////////////
								// Starting Lookup Table
								// "org.talend.designer.xmlmap.model.emf.xmlmap.impl.InputXmlTreeImpl@18b2a9a (expressionFilter: null, activateExpressionFilter: false, activateCondensedTool: false, minimized: false, name: row5) (lookup: true, matchingMode: UNIQUE_MATCH, lookupMode: LOAD_ONCE, innerJoin: true, persistent: false)"
								// /////////////////////////////////////////////
								// tHash_Lookup_row5.initGet();

								boolean forceLooprow5 = false;
								row5Struct row5ObjectFromLookup = null;

								if (!rejectedDocInnerJoin_tXMLMap_1) {

									row5HashKey.countryCode = treeNodeAPI_tXMLMap_1
											.get_String("row2.payload:/air:getAirportInformationByISOCountryCode/air:CountryAbbrviation");
									row5HashKey.hashCodeDirty = true;
									tHash_Lookup_row5.lookup(row5HashKey);
									if (!tHash_Lookup_row5.hasNext()) {

										rejectedDocInnerJoin_tXMLMap_1 = true;

									}

								}

								// rejectedDocInnerJoin_tXMLMap_1 = false;

								if (!rejectedInnerJoin_tXMLMap_1) {
									tHash_Lookup_row5.lookup(row5HashKey);
									if (tHash_Lookup_row5.hasNext()) {
										forceLooprow5 = true;
									}
								} else {
									forceLooprow5 = true;
								}

								while (tHash_Lookup_row5.hasNext()
										|| forceLooprow5) {

									row5Struct fromLookup_row5 = null;
									row5 = row5Default;

									if (!forceLooprow5) {
										fromLookup_row5 = tHash_Lookup_row5
												.next();
										if (fromLookup_row5 != null) {
											row5 = fromLookup_row5;
										}
									}
									forceLooprow5 = false;
								}

								// //////////////////////////////////////////////////////

								{
									Var__tXMLMap_1__Struct Var = Var__tXMLMap_1;

									// ###############################
									// # Outputs initialization
									boolean rejected_tXMLMap_1 = true;
									boolean alreadyMapped_tXMLMap_1 = false;
									request_XML = null;
									// output table :'request_XML'
									if (!rejectedDocInnerJoin_tXMLMap_1) {
										gen_Doc_request_XML_tXMLMap_1
												.generateElements(
														treeNodeAPI_tXMLMap_1,
														rejectedDocInnerJoin_tXMLMap_1

														, row2, row5, Var);

										if (request_XML_tmp.payload == null) {
											request_XML_tmp.payload = new Document();
											request_XML_tmp.payload
													.setDocument(gen_Doc_request_XML_tXMLMap_1
															.getDocument());
										}

										request_XML_save = request_XML_tmp;

										if (nb_line_tXMLMap_1 >= nodeList_tXMLMap_1
												.size())
											request_XML = request_XML_tmp;

									} // end for doc rejection
								}// end var

								if (nb_line_tXMLMap_1 == nodeList_tXMLMap_1
										.size()) {
									request_XML = request_XML_save;
								}

								tos_count_tXMLMap_1++;

								/**
								 * [tXMLMap_1 main ] stop
								 */
								// Start of branch "request_XML"
								if (request_XML != null) {

									/**
									 * [tLogRow_3 main ] start
									 */

									currentComponent = "tLogRow_3";

									// /////////////////////

									strBuffer_tLogRow_3 = new StringBuilder();

									if (request_XML.payload != null) { //

										strBuffer_tLogRow_3.append(String
												.valueOf(request_XML.payload));

									} //

									if (globalMap.get("tLogRow_CONSOLE") != null) {
										consoleOut_tLogRow_3 = (java.io.PrintStream) globalMap
												.get("tLogRow_CONSOLE");
									} else {
										consoleOut_tLogRow_3 = new java.io.PrintStream(
												new java.io.BufferedOutputStream(
														System.out));
										globalMap.put("tLogRow_CONSOLE",
												consoleOut_tLogRow_3);
									}

									consoleOut_tLogRow_3
											.println(strBuffer_tLogRow_3
													.toString());
									consoleOut_tLogRow_3.flush();
									nb_line_tLogRow_3++;
									// ////

									// ////

									// /////////////////////

									row3 = request_XML;

									tos_count_tLogRow_3++;

									/**
									 * [tLogRow_3 main ] stop
									 */

									/**
									 * [tESBProviderResponse_1 main ] start
									 */

									currentComponent = "tESBProviderResponse_1";

									Document esbProviderResponseDoc_tESBProviderResponse_1 = row3.payload;

									ESBProviderCallbackTalendJobInner esbProviderCallback_tESBProviderResponse_1 = (ESBProviderCallbackTalendJobInner) globalMap
											.get("esbHandler");
									if (null != esbProviderCallback_tESBProviderResponse_1) {
										esbProviderCallback_tESBProviderResponse_1
												.sendResponse(esbProviderResponseDoc_tESBProviderResponse_1
														.getDocument());
									}

									tos_count_tESBProviderResponse_1++;

									/**
									 * [tESBProviderResponse_1 main ] stop
									 */

								} // End of branch "request_XML"

							} // G_TXM_M_001 close

							/**
							 * [tESBProviderRequest_1 end ] start
							 */

							currentComponent = "tESBProviderRequest_1";

						} catch (ESBJobInterruptedException e) {
							// job interrupted from outside
							break;
						} catch (Throwable e) {
							((ESBProviderCallbackTalendJobInner) globalMap
									.get("esbHandler")).sendFault(e);
						} finally {
							// Exit from this loop is made by the configuring
							// "Keep listening"
							// parameter to false. Then we will have a break
							// before.
							if ("false".equals("true")) {
								break;
							}
						}
						nb_line_tESBProviderRequest_1++;
						globalMap.put("tESBProviderRequest_1_NB_LINE",
								nb_line_tESBProviderRequest_1);
					} // This is the end of the ESB Service Provider loop
				} finally {
					// for "keep listening" == false web service need a time to
					// serve response
					Thread.currentThread();
					Thread.sleep(500);
					// unsubscribe
					if (null != handlerThread_tESBProviderRequest_1) {
						// stop endpoint in case it was opened by job
						handlerThread_tESBProviderRequest_1.stopEndpoint();
					}
				}

				ok_Hash.put("tESBProviderRequest_1", true);
				end_Hash.put("tESBProviderRequest_1", System
						.currentTimeMillis());

				/**
				 * [tESBProviderRequest_1 end ] stop
				 */

				/**
				 * [tLogRow_1 end ] start
				 */

				currentComponent = "tLogRow_1";

				// ////
				// ////
				globalMap.put("tLogRow_1_NB_LINE", nb_line_tLogRow_1);

				// /////////////////////

				ok_Hash.put("tLogRow_1", true);
				end_Hash.put("tLogRow_1", System.currentTimeMillis());

				/**
				 * [tLogRow_1 end ] stop
				 */

				/**
				 * [tXMLMap_1 end ] start
				 */

				currentComponent = "tXMLMap_1";

				ok_Hash.put("tXMLMap_1", true);
				end_Hash.put("tXMLMap_1", System.currentTimeMillis());

				/**
				 * [tXMLMap_1 end ] stop
				 */

				/**
				 * [tLogRow_3 end ] start
				 */

				currentComponent = "tLogRow_3";

				// ////
				// ////
				globalMap.put("tLogRow_3_NB_LINE", nb_line_tLogRow_3);

				// /////////////////////

				ok_Hash.put("tLogRow_3", true);
				end_Hash.put("tLogRow_3", System.currentTimeMillis());

				/**
				 * [tLogRow_3 end ] stop
				 */

				/**
				 * [tESBProviderResponse_1 end ] start
				 */

				currentComponent = "tESBProviderResponse_1";

				ok_Hash.put("tESBProviderResponse_1", true);
				end_Hash.put("tESBProviderResponse_1", System
						.currentTimeMillis());

				/**
				 * [tESBProviderResponse_1 end ] stop
				 */

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		} catch (Error error) {

			throw new Error(error);

		} finally {
			// free memory for "tXMLMap_1"
			globalMap.put("tHash_row5", null);

		}

		globalMap.put("tESBProviderRequest_1_SUBPROCESS_STATE", 1);
	}

	public static class row5Struct implements
			routines.system.IPersistableComparableLookupRow<row5Struct> {
		final static byte[] commonByteArrayLock = new byte[0];
		static byte[] commonByteArray = new byte[0];
		private static final int DEFAULT_HASHCODE = 1;
		private static final int PRIME = 31;
		private int hashCode = DEFAULT_HASHCODE;
		public boolean hashCodeDirty = true;

		public String countryCode;

		public String getCountryCode() {
			return this.countryCode;
		}

		public String airportsInformations;

		public String getAirportsInformations() {
			return this.airportsInformations;
		}

		@Override
		public int hashCode() {
			if (this.hashCodeDirty) {
				final int prime = PRIME;
				int result = DEFAULT_HASHCODE;

				result = prime
						* result
						+ ((this.countryCode == null) ? 0 : this.countryCode
								.hashCode());

				this.hashCode = result;
				this.hashCodeDirty = false;
			}
			return this.hashCode;
		}

		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			final row5Struct other = (row5Struct) obj;

			if (this.countryCode == null) {
				if (other.countryCode != null)
					return false;
			} else if (!this.countryCode.equals(other.countryCode))
				return false;

			return true;
		}

		public void copyDataTo(row5Struct other) {

			other.countryCode = this.countryCode;
			other.airportsInformations = this.airportsInformations;

		}

		public void copyKeysDataTo(row5Struct other) {

			other.countryCode = this.countryCode;

		}

		private String readString(ObjectInputStream dis) throws IOException {
			String strReturn = null;
			int length = 0;
			length = dis.readInt();
			if (length == -1) {
				strReturn = null;
			} else {
				if (length > commonByteArray.length) {
					if (length < 1024 && commonByteArray.length == 0) {
						commonByteArray = new byte[1024];
					} else {
						commonByteArray = new byte[2 * length];
					}
				}
				dis.readFully(commonByteArray, 0, length);
				strReturn = new String(commonByteArray, 0, length, utf8Charset);
			}
			return strReturn;
		}

		private void writeString(String str, ObjectOutputStream dos)
				throws IOException {
			if (str == null) {
				dos.writeInt(-1);
			} else {
				byte[] byteArray = str.getBytes(utf8Charset);
				dos.writeInt(byteArray.length);
				dos.write(byteArray);
			}
		}

		private String readString(DataInputStream dis, ObjectInputStream ois)
				throws IOException {
			String strReturn = null;
			int length = 0;
			length = dis.readInt();
			if (length == -1) {
				strReturn = null;
			} else {
				byte[] byteArray = new byte[length];
				dis.read(byteArray);
				strReturn = new String(byteArray, utf8Charset);
			}
			return strReturn;
		}

		private void writeString(String str, DataOutputStream dos,
				ObjectOutputStream oos) throws IOException {
			if (str == null) {
				dos.writeInt(-1);
			} else {
				byte[] byteArray = str.getBytes(utf8Charset);
				dos.writeInt(byteArray.length);
				dos.write(byteArray);
			}
		}

		public void readKeysData(ObjectInputStream dis) {

			synchronized (commonByteArrayLock) {

				try {

					int length = 0;

					this.countryCode = readString(dis);

				} catch (IOException e) {
					throw new RuntimeException(e);

				}

			}

		}

		public void writeKeysData(ObjectOutputStream dos) {
			try {

				// String

				writeString(this.countryCode, dos);

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		/**
		 * Fill Values data by reading ObjectInputStream.
		 */
		public void readValuesData(DataInputStream dis, ObjectInputStream ois) {
			try {

				int length = 0;

				this.airportsInformations = readString(dis, ois);

			} catch (IOException e) {
				throw new RuntimeException(e);

			}

		}

		/**
		 * Return a byte array which represents Values data.
		 */
		public void writeValuesData(DataOutputStream dos, ObjectOutputStream oos) {
			try {

				writeString(this.airportsInformations, dos, oos);

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		public String toString() {

			StringBuilder sb = new StringBuilder();
			sb.append(super.toString());
			sb.append("[");
			sb.append("countryCode=" + countryCode);
			sb.append(",airportsInformations=" + airportsInformations);
			sb.append("]");

			return sb.toString();
		}

		/**
		 * Compare keys
		 */
		public int compareTo(row5Struct other) {

			int returnValue = -1;

			returnValue = checkNullsAndCompare(this.countryCode,
					other.countryCode);
			if (returnValue != 0) {
				return returnValue;
			}

			return returnValue;
		}

		private int checkNullsAndCompare(Object object1, Object object2) {
			int returnValue = 0;
			if (object1 instanceof Comparable && object2 instanceof Comparable) {
				returnValue = ((Comparable) object1).compareTo(object2);
			} else if (object1 != null && object2 != null) {
				returnValue = compareStrings(object1.toString(), object2
						.toString());
			} else if (object1 == null && object2 != null) {
				returnValue = 1;
			} else if (object1 != null && object2 == null) {
				returnValue = -1;
			} else {
				returnValue = 0;
			}

			return returnValue;
		}

		private int compareStrings(String string1, String string2) {
			return string1.compareTo(string2);
		}

	}

	public static class row4Struct implements
			routines.system.IPersistableRow<row4Struct> {
		final static byte[] commonByteArrayLock = new byte[0];
		static byte[] commonByteArray = new byte[0];

		public String countryCode;

		public String getCountryCode() {
			return this.countryCode;
		}

		public String airportsInformations;

		public String getAirportsInformations() {
			return this.airportsInformations;
		}

		private String readString(ObjectInputStream dis) throws IOException {
			String strReturn = null;
			int length = 0;
			length = dis.readInt();
			if (length == -1) {
				strReturn = null;
			} else {
				if (length > commonByteArray.length) {
					if (length < 1024 && commonByteArray.length == 0) {
						commonByteArray = new byte[1024];
					} else {
						commonByteArray = new byte[2 * length];
					}
				}
				dis.readFully(commonByteArray, 0, length);
				strReturn = new String(commonByteArray, 0, length, utf8Charset);
			}
			return strReturn;
		}

		private void writeString(String str, ObjectOutputStream dos)
				throws IOException {
			if (str == null) {
				dos.writeInt(-1);
			} else {
				byte[] byteArray = str.getBytes(utf8Charset);
				dos.writeInt(byteArray.length);
				dos.write(byteArray);
			}
		}

		public void readData(ObjectInputStream dis) {

			synchronized (commonByteArrayLock) {

				try {

					int length = 0;

					this.countryCode = readString(dis);

					this.airportsInformations = readString(dis);

				} catch (IOException e) {
					throw new RuntimeException(e);

				}

			}

		}

		public void writeData(ObjectOutputStream dos) {
			try {

				// String

				writeString(this.countryCode, dos);

				// String

				writeString(this.airportsInformations, dos);

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		public String toString() {

			StringBuilder sb = new StringBuilder();
			sb.append(super.toString());
			sb.append("[");
			sb.append("countryCode=" + countryCode);
			sb.append(",airportsInformations=" + airportsInformations);
			sb.append("]");

			return sb.toString();
		}

		/**
		 * Compare keys
		 */
		public int compareTo(row4Struct other) {

			int returnValue = -1;

			return returnValue;
		}

		private int checkNullsAndCompare(Object object1, Object object2) {
			int returnValue = 0;
			if (object1 instanceof Comparable && object2 instanceof Comparable) {
				returnValue = ((Comparable) object1).compareTo(object2);
			} else if (object1 != null && object2 != null) {
				returnValue = compareStrings(object1.toString(), object2
						.toString());
			} else if (object1 == null && object2 != null) {
				returnValue = 1;
			} else if (object1 != null && object2 == null) {
				returnValue = -1;
			} else {
				returnValue = 0;
			}

			return returnValue;
		}

		private int compareStrings(String string1, String string2) {
			return string1.compareTo(string2);
		}

	}

	public void tFileInputDelimited_1Process(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tFileInputDelimited_1_SUBPROCESS_STATE", 0);

		final boolean execStat = this.execStat;

		String iterateId = "";
		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume
				globalResumeTicket = true;

				row4Struct row4 = new row4Struct();
				row4Struct row5 = row4;

				/**
				 * [tAdvancedHash_row5 begin ] start
				 */

				ok_Hash.put("tAdvancedHash_row5", false);
				start_Hash
						.put("tAdvancedHash_row5", System.currentTimeMillis());
				currentComponent = "tAdvancedHash_row5";

				int tos_count_tAdvancedHash_row5 = 0;

				// connection name:row5
				// source node:tLogRow_4 - inputs:(row4) outputs:(row5,row5) |
				// target node:tAdvancedHash_row5 - inputs:(row5) outputs:()
				// linked node: tXMLMap_1 - inputs:(row2,row5)
				// outputs:(request_XML)

				org.talend.designer.components.lookup.common.ICommonLookup.MATCHING_MODE matchingModeEnum_row5 = org.talend.designer.components.lookup.common.ICommonLookup.MATCHING_MODE.UNIQUE_MATCH;

				org.talend.designer.components.lookup.memory.AdvancedMemoryLookup<row5Struct> tHash_Lookup_row5 = org.talend.designer.components.lookup.memory.AdvancedMemoryLookup
						.<row5Struct> getLookup(matchingModeEnum_row5);

				globalMap.put("tHash_Lookup_row5", tHash_Lookup_row5);

				/**
				 * [tAdvancedHash_row5 begin ] stop
				 */

				/**
				 * [tLogRow_4 begin ] start
				 */

				ok_Hash.put("tLogRow_4", false);
				start_Hash.put("tLogRow_4", System.currentTimeMillis());
				currentComponent = "tLogRow_4";

				int tos_count_tLogRow_4 = 0;

				// /////////////////////

				final String OUTPUT_FIELD_SEPARATOR_tLogRow_4 = "|";
				java.io.PrintStream consoleOut_tLogRow_4 = null;

				StringBuilder strBuffer_tLogRow_4 = null;
				int nb_line_tLogRow_4 = 0;
				// /////////////////////

				/**
				 * [tLogRow_4 begin ] stop
				 */

				/**
				 * [tFileInputDelimited_1 begin ] start
				 */

				ok_Hash.put("tFileInputDelimited_1", false);
				start_Hash.put("tFileInputDelimited_1", System
						.currentTimeMillis());
				currentComponent = "tFileInputDelimited_1";

				int tos_count_tFileInputDelimited_1 = 0;

				int nb_line_tFileInputDelimited_1 = 0;
				org.talend.fileprocess.FileInputDelimited fid_tFileInputDelimited_1 = null;
				try {
					try {
						fid_tFileInputDelimited_1 = new org.talend.fileprocess.FileInputDelimited(
								"/data/home/jguillemotte/Java-tools/TESB_SE-All-r67267-V4.2.1/workspace/countryInfos.csv",
								"ISO-8859-15", ";", "\n", true, 0, 0, -1, -1,
								false);
					} catch (Exception e) {

						System.err.println(e.getMessage());

					}
					while (fid_tFileInputDelimited_1 != null
							&& fid_tFileInputDelimited_1.nextRecord()) {
						row4 = null;
						boolean whetherReject_tFileInputDelimited_1 = false;
						row4 = new row4Struct();
						try {

							row4.countryCode = fid_tFileInputDelimited_1.get(0);
							row4.airportsInformations = fid_tFileInputDelimited_1
									.get(1);

						} catch (Exception e) {
							whetherReject_tFileInputDelimited_1 = true;
							System.err.println(e.getMessage());
							row4 = null;
						}

						/**
						 * [tFileInputDelimited_1 begin ] stop
						 */
						/**
						 * [tFileInputDelimited_1 main ] start
						 */

						currentComponent = "tFileInputDelimited_1";

						tos_count_tFileInputDelimited_1++;

						/**
						 * [tFileInputDelimited_1 main ] stop
						 */
						// Start of branch "row4"
						if (row4 != null) {

							/**
							 * [tLogRow_4 main ] start
							 */

							currentComponent = "tLogRow_4";

							// /////////////////////

							strBuffer_tLogRow_4 = new StringBuilder();

							if (row4.countryCode != null) { //

								strBuffer_tLogRow_4.append(String
										.valueOf(row4.countryCode));

							} //

							strBuffer_tLogRow_4.append("|");

							if (row4.airportsInformations != null) { //

								strBuffer_tLogRow_4.append(String
										.valueOf(row4.airportsInformations));

							} //

							if (globalMap.get("tLogRow_CONSOLE") != null) {
								consoleOut_tLogRow_4 = (java.io.PrintStream) globalMap
										.get("tLogRow_CONSOLE");
							} else {
								consoleOut_tLogRow_4 = new java.io.PrintStream(
										new java.io.BufferedOutputStream(
												System.out));
								globalMap.put("tLogRow_CONSOLE",
										consoleOut_tLogRow_4);
							}

							consoleOut_tLogRow_4.println(strBuffer_tLogRow_4
									.toString());
							consoleOut_tLogRow_4.flush();
							nb_line_tLogRow_4++;
							// ////

							// ////

							// /////////////////////

							row5 = row4;

							tos_count_tLogRow_4++;

							/**
							 * [tLogRow_4 main ] stop
							 */

							/**
							 * [tAdvancedHash_row5 main ] start
							 */

							currentComponent = "tAdvancedHash_row5";

							row5Struct row5_HashRow = new row5Struct();

							row5_HashRow.countryCode = row5.countryCode;

							row5_HashRow.airportsInformations = row5.airportsInformations;

							tHash_Lookup_row5.put(row5_HashRow);

							tos_count_tAdvancedHash_row5++;

							/**
							 * [tAdvancedHash_row5 main ] stop
							 */

						} // End of branch "row4"

						/**
						 * [tFileInputDelimited_1 end ] start
						 */

						currentComponent = "tFileInputDelimited_1";

					}
				} finally {
					if (!((Object) ("/data/home/jguillemotte/Java-tools/TESB_SE-All-r67267-V4.2.1/workspace/countryInfos.csv") instanceof java.io.InputStream)) {
						if (fid_tFileInputDelimited_1 != null) {
							fid_tFileInputDelimited_1.close();
						}
					}
					if (fid_tFileInputDelimited_1 != null) {
						globalMap.put("tFileInputDelimited_1_NB_LINE",
								fid_tFileInputDelimited_1.getRowNumber());
					}
				}

				ok_Hash.put("tFileInputDelimited_1", true);
				end_Hash.put("tFileInputDelimited_1", System
						.currentTimeMillis());

				/**
				 * [tFileInputDelimited_1 end ] stop
				 */

				/**
				 * [tLogRow_4 end ] start
				 */

				currentComponent = "tLogRow_4";

				// ////
				// ////
				globalMap.put("tLogRow_4_NB_LINE", nb_line_tLogRow_4);

				// /////////////////////

				ok_Hash.put("tLogRow_4", true);
				end_Hash.put("tLogRow_4", System.currentTimeMillis());

				/**
				 * [tLogRow_4 end ] stop
				 */

				/**
				 * [tAdvancedHash_row5 end ] start
				 */

				currentComponent = "tAdvancedHash_row5";

				tHash_Lookup_row5.endPut();

				ok_Hash.put("tAdvancedHash_row5", true);
				end_Hash.put("tAdvancedHash_row5", System.currentTimeMillis());

				/**
				 * [tAdvancedHash_row5 end ] stop
				 */

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		} catch (Error error) {

			throw new Error(error);

		}

		globalMap.put("tFileInputDelimited_1_SUBPROCESS_STATE", 1);
	}

	public String resuming_logs_dir_path = null;
	public String resuming_checkpoint_path = null;
	public String parent_part_launcher = null;
	private String resumeEntryMethodName = null;
	private boolean globalResumeTicket = false;

	public boolean watch = false;
	// portStats is null, it means don't execute the statistics
	public Integer portStats = null;
	public int portTraces = 4334;
	public String clientHost;
	public String defaultClientHost = "localhost";
	public String contextStr = "Default";
	public boolean isDefaultContext = true;
	public String pid = "0";
	public String rootPid = null;
	public String fatherPid = null;
	public String fatherNode = null;
	public long startTime = 0;
	public boolean isChildJob = false;

	private boolean execStat = true;

	private ThreadLocal threadLocal = new ThreadLocal();
	{
		java.util.Map threadRunResultMap = new java.util.HashMap();
		threadRunResultMap.put("errorCode", null);
		threadRunResultMap.put("status", "");
		threadLocal.set(threadRunResultMap);
	}

	private java.util.Properties context_param = new java.util.Properties();
	public java.util.Map<String, Object> parentContextMap = new java.util.HashMap<String, Object>();

	public String status = "";

	public static void main(String[] args) {
		final SimpleProvider SimpleProviderClass = new SimpleProvider();

		int exitCode = SimpleProviderClass.runJobInTOS(args);

		System.exit(exitCode);
	}

	public String[][] runJob(String[] args) {

		int exitCode = runJobInTOS(args);
		String[][] bufferValue = new String[][] { { Integer.toString(exitCode) } };

		return bufferValue;
	}

	public int runJobInTOS(String[] args) {

		String lastStr = "";
		for (String arg : args) {
			if (arg.equalsIgnoreCase("--context_param")) {
				lastStr = arg;
			} else if (lastStr.equals("")) {
				evalParam(arg);
			} else {
				evalParam(lastStr + " " + arg);
				lastStr = "";
			}
		}

		if (clientHost == null) {
			clientHost = defaultClientHost;
		}

		if (pid == null || "0".equals(pid)) {
			pid = TalendString.getAsciiRandomString(6);
		}

		if (rootPid == null) {
			rootPid = pid;
		}
		if (fatherPid == null) {
			fatherPid = pid;
		} else {
			isChildJob = true;
		}

		try {
			// call job/subjob with an existing context, like:
			// --context=production. if without this parameter, there will use
			// the default context instead.
			java.io.InputStream inContext = SimpleProvider.class
					.getClassLoader().getResourceAsStream(
							"talend_esb_tutorial/simpleprovider_0_1/contexts/"
									+ contextStr + ".properties");
			if (isDefaultContext && inContext == null) {

			} else {
				if (inContext != null) {
					// defaultProps is in order to keep the original context
					// value
					defaultProps.load(inContext);
					inContext.close();
					context = new ContextProperties(defaultProps);
				} else {
					// print info and job continue to run, for case:
					// context_param is not empty.
					System.err.println("Could not find the context "
							+ contextStr);
				}

				if (!context_param.isEmpty()) {
					context.putAll(context_param);
				}

			}
		} catch (java.io.IOException ie) {
			System.err.println("Could not load context " + contextStr);
			ie.printStackTrace();
		}

		// get context value from parent directly
		if (parentContextMap != null && !parentContextMap.isEmpty()) {

		}

		// Resume: init the resumeUtil
		resumeEntryMethodName = ResumeUtil
				.getResumeEntryMethodName(resuming_checkpoint_path);
		resumeUtil = new ResumeUtil(resuming_logs_dir_path, isChildJob, rootPid);
		resumeUtil.initCommonInfo(pid, rootPid, fatherPid, projectName,
				jobName, contextStr, jobVersion);

		// Resume: jobStart
		resumeUtil.addLog("JOB_STARTED", "JOB:" + jobName,
				parent_part_launcher, Thread.currentThread().getId() + "", "",
				"", "", "", resumeUtil.convertToJsonText(context));

		long startUsedMemory = Runtime.getRuntime().totalMemory()
				- Runtime.getRuntime().freeMemory();
		long endUsedMemory = 0;
		long end = 0;

		startTime = System.currentTimeMillis();

		this.globalResumeTicket = true;// to run tPreJob

		this.globalResumeTicket = false;// to run others jobs

		try {
			errorCode = null;
			tESBProviderRequest_1Process(globalMap);
			if (!"failure".equals(status)) {
				status = "end";
			}
		} catch (TalendException e_tESBProviderRequest_1) {
			status = "failure";
			e_tESBProviderRequest_1.printStackTrace();
			globalMap.put("tESBProviderRequest_1_SUBPROCESS_STATE", -1);

		} finally {
		}

		this.globalResumeTicket = true;// to run tPostJob

		end = System.currentTimeMillis();

		if (watch) {
			System.out.println((end - startTime) + " milliseconds");
		}

		endUsedMemory = Runtime.getRuntime().totalMemory()
				- Runtime.getRuntime().freeMemory();
		if (false) {
			System.out.println((endUsedMemory - startUsedMemory)
					+ " bytes memory increase when running : SimpleProvider");
		}

		int returnCode = 0;
		if (errorCode == null) {
			returnCode = status != null && status.equals("failure") ? 1 : 0;
		} else {
			returnCode = errorCode.intValue();
		}
		resumeUtil.addLog("JOB_ENDED", "JOB:" + jobName, parent_part_launcher,
				Thread.currentThread().getId() + "", "", "" + returnCode, "",
				"", "");

		return returnCode;

	}

	private void evalParam(String arg) {
		if (arg.startsWith("--resuming_logs_dir_path")) {
			resuming_logs_dir_path = arg.substring(25);
		} else if (arg.startsWith("--resuming_checkpoint_path")) {
			resuming_checkpoint_path = arg.substring(27);
		} else if (arg.startsWith("--parent_part_launcher")) {
			parent_part_launcher = arg.substring(23);
		} else if (arg.startsWith("--watch")) {
			watch = true;
		} else if (arg.startsWith("--stat_port=")) {
			String portStatsStr = arg.substring(12);
			if (portStatsStr != null && !portStatsStr.equals("null")) {
				portStats = Integer.parseInt(portStatsStr);
			}
		} else if (arg.startsWith("--trace_port=")) {
			portTraces = Integer.parseInt(arg.substring(13));
		} else if (arg.startsWith("--client_host=")) {
			clientHost = arg.substring(14);
		} else if (arg.startsWith("--context=")) {
			contextStr = arg.substring(10);
			isDefaultContext = false;
		} else if (arg.startsWith("--father_pid=")) {
			fatherPid = arg.substring(13);
		} else if (arg.startsWith("--root_pid=")) {
			rootPid = arg.substring(11);
		} else if (arg.startsWith("--father_node=")) {
			fatherNode = arg.substring(14);
		} else if (arg.startsWith("--pid=")) {
			pid = arg.substring(6);
		} else if (arg.startsWith("--context_param")) {
			String keyValue = arg.substring(16);
			int index = -1;
			if (keyValue != null && (index = keyValue.indexOf('=')) > -1) {
				context_param.put(keyValue.substring(0, index),
						replaceEscapeChars(keyValue.substring(index + 1)));
			}
		}

	}

	private final String[][] escapeChars = { { "\\n", "\n" }, { "\\'", "\'" },
			{ "\\r", "\r" }, { "\\f", "\f" }, { "\\b", "\b" }, { "\\t", "\t" },
			{ "\\\\", "\\" } };

	private String replaceEscapeChars(String keyValue) {
		if (keyValue == null || ("").equals(keyValue.trim())) {
			return keyValue;
		}
		for (String[] strArray : escapeChars) {
			keyValue = keyValue.replace(strArray[0], strArray[1]);
		}
		return keyValue;
	}

	public Integer getErrorCode() {
		return errorCode;
	}

	public String getStatus() {
		return status;
	}

	ResumeUtil resumeUtil = null;
}
/************************************************************************************************
 * 85127 characters generated by Talend ESB Standard Edition on the 4 octobre
 * 2011 16:40:58 CEST
 ************************************************************************************************/
